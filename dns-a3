#!/usr/bin/env python3.7

###########
# IMPORTS #
###########

import sys
import argparse
import random
import asyncio
import aiodns
import functools

####################
# GLOBAL VARIABLES #
####################

global addresses
global tasks
global resolver
global semaphore

#############
# FUNCTIONS #
#############

async def query(name):
    return await resolver.query(name, 'A')

def result_callback(name, future):
    semaphore.release()
    if future.exception() is not None:
        try:
            err_number = future.exception().args[0]
            err_text = future.exception().args[1]
        except IndexError:
            sys.stderr.write(f"{name} => Couldn't parse exception: {future.exception()}\n")
        else:
            if err_number == 4:
                #sys.stderr.write(f"{name} => No record found.\n")
                pass
            elif err_number == 12:
                # Timeout from DNS server
                sys.stderr.write(f"{name} => Request timed out.\n")
            elif err_number == 1:
                # Server answered with no data
                pass
            else:
                sys.stderr.write(f"{name} =>  Unexpected exception: {future.exception()}\n")
    else:
        for a in future.result():
            if addresses is None or a.host in addresses:
                sys.stdout.write('%s,%s\n' % (a.host, name))
                sys.stdout.flush()
    tasks.remove(future)

async def queue_queries(addresses):
    for address in addresses:
        # Wait on the semaphore before adding more tasks
        await semaphore.acquire()
        task = asyncio.ensure_future(query(address))
        task.add_done_callback(functools.partial(result_callback, address))
        tasks.append(task)
    await asyncio.gather(*tasks, return_exceptions=True)


########
# MAIN #
########

if __name__ == '__main__':
    desc = 'Perform DNS lookup on supplied hostnames and output results in CSV format.'

    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('-n', '--nameservers',
                        nargs='?',
                        type=argparse.FileType('r'),
                        action='store',
                        help='file containing a list of nameservers split by a newline, otherwise use system resolver',
                        metavar='FILE',
                        default=None)
    parser.add_argument('-f', '--filter',
                        nargs='?',
                        type=argparse.FileType('r'),
                        action='store',
                        help='a list of IP addresses to filter against, only matching results are printed',
                        metavar='FILE',
                        default=None)
    parser.add_argument('file',
                        nargs='?',
                        type=argparse.FileType('r'),
                        action='store',
                        help='file containing a list of hostnames split by a newline, otherwise read from STDIN',
                        metavar='FILE',
                        default=sys.stdin)
    parser.add_argument('-q', '--queries',
                        type=int,
                        action='store',
                        help='maximum number of queries to run asynchronosly (default: 100)',
                        metavar='INT',
                        default='100')
    args = parser.parse_args()

    if args.filter:
        addresses = [line.strip() for line in args.filter if len(line.strip())>0 and line[0] is not '#']
    else:
        addresses = None

    try:
        hostnames = [line.strip() for line in args.file if len(line.strip())>0 and line[0] is not '#']
    except KeyboardInterrupt:
        sys.stderr.write("Caught keyboard interrupt, cleaning up...")
        exit()

    # remove duplicates and sort
    hostnames = sorted(set(hostnames))

    if args.nameservers:
        try:
            nameservers = [line.strip() for line in args.nameservers if len(line.strip())>0 and line[0] is not '#']
        except KeyboardInterrupt:
            sys.stderr.write("Caught keyboard interrupt, cleaning up...")
            exit()
        
    loop = asyncio.get_event_loop()
    resolver = aiodns.DNSResolver(loop=loop, rotate=True)
    if args.nameservers:
        resolver.nameservers = nameservers
    semaphore = asyncio.BoundedSemaphore(args.queries)
    tasks = list()

    try:
        loop.run_until_complete(queue_queries(hostnames))
    except KeyboardInterrupt:
        sys.stderr.write("Caught keyboard interrupt, cleaning up...")
        asyncio.gather(*asyncio.Task.all_tasks()).cancel()
        loop.stop()
    finally:
        loop.close()